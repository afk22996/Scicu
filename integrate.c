#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

static double _scalex(double x, double a, double b){return 0.5*(x+1)*(b-a) + a;}
static double _scalew(double w, double a, double b){return 0.5*(b-a)*w;}
double G25(double (*f)(double), double a, double b){
	double gauss[13][2] = {{0,1.231760537267154512039028730790501e-01},{1.228646926107103963873598188080368e-01,1.222424429903100416889595189458515e-01},
	{2.438668837209884320451903627974516e-01,1.194557635357847722281781265129010e-01},{3.611723058093878377358217301276407e-01,1.148582591457116483393255458695558e-01}, 
	{4.730027314457149605221821150091920e-01,1.085196244742636531160939570501166e-01},{5.776629302412229677236898416126541e-01,1.005359490670506442022068903926858e-01},
	{6.735663684734683644851206332476222e-01,9.102826198296364981149722070289165e-02},{7.592592630373576305772828652043610e-01,8.014070033500101801323495966911130e-02},
	{8.334426287608340014210211086935696e-01,6.803833381235691720718718565670797e-02},{8.949919978782753688510420067828050e-01,5.490469597583519192593689154047332e-02},
	{9.429745712289743394140111696584705e-01,4.093915670130631265562348771164595e-02},{9.766639214595175114983153864795941e-01,2.635498661503213726190181529529914e-02},
	{9.955569697904980979087849468939016e-01,1.139379850102628794790296411323477e-02}};

	double gsum = 0;
	double x,w,wi;

	for(int i = 0; i < 13; i++){
		x = gauss[i][0];
		w = gauss[i][1];
		wi = _scalew(w, a, b);
		if(x == 0){
			gsum += wi*f(_scalex(x, a, b));
		}
		else{
			gsum += wi*(f(_scalex(-x, a, b)) + f(_scalex(x, a, b)));
		}
	}
	return gsum;
}

double K51(double (*f)(double), double a, double b){
	double kronrod[26][2] = {{0,6.158081806783293507875982424006455e-02},{6.154448300568507888654639236679663e-02,6.147118987142531666154413196526418e-02},
	{1.228646926107103963873598188080368e-01,6.112850971705304830585903041629271e-02},{1.837189394210488920159698887595284e-01,6.053945537604586294536026751756543e-02},
	{2.438668837209884320451903627974516e-01,5.972034032417405997909929193256185e-02},{3.030895389311078301674789099803393e-01,5.868968002239420796197417585678776e-02},
	{3.611723058093878377358217301276407e-01,5.743711636156783285358269393950647e-02},{4.178853821930377488518143945945725e-01,5.595081122041231730824068638274735e-02},
	{4.730027314457149605221821150091920e-01,5.425112988854549014454337045987561e-02},{5.263252843347191825996237781580102e-01,5.236288580640747586436671213787271e-02},
	{5.776629302412229677236898416126541e-01,5.027767908071567196332525943344008e-02},{6.268100990103174127881226816245179e-01,4.798253713883671390639225575691475e-02},
	{6.735663684734683644851206332476222e-01,4.550291304992178890987058475266039e-02},{7.177664068130843881866540797732978e-01,4.287284502017004947689579243949516e-02},
	{7.592592630373576305772828652043610e-01,4.008382550403238207483928446707565e-02},{7.978737979985000594104109049943066e-01,3.711627148341554356033062536761988e-02},
	{8.334426287608340014210211086935696e-01,3.400213027432933783674879522955120e-02},{8.658470652932755954489969695883401e-01,3.079230016738748889110902021522859e-02},
	{8.949919978782753688510420067828050e-01,2.747531758785173780294845551781108e-02},{9.207471152817015617463460845463306e-01,2.400994560695321622009248916488108e-02},
	{9.429745712289743394140111696584705e-01,2.043537114588283545656829223593897e-02},{9.616149864258425124181300336601672e-01,1.684781770912829823151666753633632e-02},
	{9.766639214595175114983153864795941e-01,1.323622919557167481365640584697624e-02},{9.880357945340772476373310145774062e-01,9.473973386174151607207710523655324e-03},
	{9.955569697904980979087849468939016e-01,5.561932135356713758040236901065522e-03},{9.992621049926098341934574865403406e-01,1.987383892330315926507851882843410e-03}};

	double ksum = 0;
	double x,w,wi;

	for(int i = 0; i < 26; i++){
		x = kronrod[i][0];
		w = kronrod[i][1];
		wi = _scalew(w, a, b);
		if(x == 0){
			ksum += wi*f(_scalex(x, a, b));
		}
		else{
			ksum += wi*(f(_scalex(-x, a, b)) + f(_scalex(x, a, b)));
		}
	}
	return ksum;
}

double aK51(double (*f)(double), double a, double b, double error){
	double g = G25(f, a, b);
	double k = K51(f, a, b);
	double eps = k - g;
	if(eps < 0){eps *= -1;}
	if(eps < error){return k;}
	else{
		double m = (a + b)*0.5;
		return aK51(f, a, m, error*0.5) + aK51(f, m, b, error*0.5);
	}
}
double func(double x){
	return pow(x, 3.5) + pow(x, -5);
}
double Func(double x){
	return (2.0/9.0)*pow(x, 4.5) - 0.25*pow(x, -4);
}
int main(void){
	double x0, x1, approx, actual, error, eps;

	x0 = 1.2;
	x1 = 10;
	eps = 1e-12;
	clock_t t0 = clock();
	approx = aK51(func, x0, x1, eps);
	clock_t t1 = clock();
	actual = Func(x1) - Func(x0);
	error = approx - actual;
	if(error < 0){error *= -1;}
	printf("Adaptive K51 Error: %.15e\nIn %.15e s\n", error, (double)(t1-t0)/CLOCKS_PER_SEC);
}